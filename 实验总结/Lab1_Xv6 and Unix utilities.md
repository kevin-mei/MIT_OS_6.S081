这个实验目的：熟悉xv6系统和它的系统调用

按计划，先阅读
1. 介绍： https://pdos.csail.mit.edu/6.828/2019/lec/l-overview.txt
2. 例子： https://pdos.csail.mit.edu/6.828/2019/lec/l-overview/
3. read chapter 1 of the xv6 book

介绍 和 例子是匹配的，例子是代码，介绍里会详细讲解代码用途和细节：
UNIX系统调用简介
* 6.S081专注于系统调用接口的设计和实现。
  我们将研究UNIX（Linux，Mac，POSIX和xv6）。
  让我们看看程序如何使用系统调用接口。
  您将在第一个实验中使用这些系统调用。
2. 实例
  示例：open.c，创建一个文件
  详细介绍了read/write的函数用法
  read()和write()是系统调用
  read()/write()第一个参数是“文件描述符”（fd）
    传递给内核以告诉它要读取/写入哪个“打开文件”
    必须先前已打开
    FD连接到文件/设备/套接字/＆c
    一个进程可以打开很多文件，有很多FD
    UNIX约定：fd 0是“标准输入”，1是“标准输出”
  read()第二个参数是指向一些要读取的内存的指针
  第三个参数是要读取的字节数
    read()可能读的少一些，但不能读更多
  返回值：实际读取的字节数
   interpretation is application-specific, e.g. C program, executable, &c
  where do file descriptors come from?  这里的&c是什么意思, 应该是等等的意思
```
  write(1, buf, n); //UNIX约定：fd 0是“标准输入”，1是“标准输出” 给标准输出中写入hello

  FD可以做一个指向“管道”的引用,就像对文件一样引用
  系统调用pipe()创建一对FD
    从第一个FD读取
    从第二个FD写入
```



* 总结下例子
  * 我们研究了UNIX的I/O，文件系统和进程抽象。
  * 接口很简单-只是整数和（拷贝）缓冲区。
  * 这些抽象结合得很好，如：用于I/O重定向。

您将在下个星期的第一个实验中使用UNIX系统调用。

【杂项】
amusement [ə'mjuzmənt] 娱乐
assignment  [ə'saɪnmənt] 任务，作业
vscode 打开


xv6 book chapter 1：

## 操作系统接口
操作系统的工作是在多个程序之间共享计算机，并提供一组比单独的硬件所支持的更有用的服务。操作系统管理和抽象底层硬件，因此，例如，一个WORD程序不需要关心它自己正在使用哪种类型的磁盘硬件。它还在多个程序之间共享硬件，以便它们同时运行(或看起来运行)。最后，操作系统为程序的交互提供了可控的方式，这样它们就可以共享数据或一起工作。

操作系统通过接口为用户程序提供服务。设计一个好的界面是很困难的。一方面，我们希望接口简单而有限，因为这样更容易实现正确。另一方面，我们可能会忍不住为应用程序提供许多复杂的特性。解决这种紧张关系的技巧是设计依赖于一些机制的接口，这些机制可以结合起来提供更多的通用性。

本书用一个简单的操作系统作为一个具体的例子来说明操作系统的概念。xv6这个操作系统提供了Ken Thompson和Dennis Ritchie的Unix操作系统[10]所介绍的基本接口，并模仿[mimicking]了Unix的内部设计。Unix提供了一个有限的接口，它的机制组合得很好，提供了惊人的通用性。这个界面非常成功，以至于现代操作系统——bsd、Linux、Mac OS X、Solaris，甚至在较小程度上，Microsoft windows——都有类似unix的界面。理解xv6是理解这些系统和其他许多系统的良好开端。
如图1.1所示，xv6采用了传统的内核形式，这是一个为运行的程序提供服务的特殊程序。每个正在运行的程序，称为一个进程，它的内存中包含指令、数据和一个堆栈。这些指令实现了程序的计算。数据是计算作用的变量。堆栈组织程序的过程调用。

当进程需要调用内核服务时，它会在插入一个程序调用操作系统接口。这样的程序称为系统调用(system call)。系统调用进入内核;内核执行服务并返回。因此，进程会在用户空间(user space)和内核空间(kernel space)之间交替执行。

内核使用CPU的硬件保护机制来确保在用户空间中执行的每个进程只能访问自己的内存。内核执行时具有实现这些保护所需的硬件特权;用户程序执行时没有这些权限;当一个用户程序调用系统调用，硬件提高权限级别并开始执行内核中预先安排的函数；

内核提供的系统调用集合是用户程序看到的接口。xv6内核提供Unix内核传统上提供的服务和系统调用的一个子集。图1.2列出了xv6的所有系统调用。

本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段和讨论shell(传统类unix系统的主要用户界面)如何使用它们来说明这些服务。shell对系统调用的使用说明了它们是如何精心设计的。

shell是一个普通的程序，它从用户那里读取命令并执行它们。shell是用户程序而不是内核的一部分，这一事实说明了系统调用接口的强大功能:shell没有什么特别之处。这也意味着shell很容易更换;因此，现代的Unix系统有多种shell可供选择，每种shell都有自己的用户界面和脚本特性。xv6 shell是Unix Bourne shell本质的一个简单实现。它的实现可以在(user/sh.c:1)找到。

## 1.1 进程和内存

xv6进程由用户空间内存(指令、数据和堆栈)和每个进程状态（内核私有的）组成。Xv6可以计时共享进程:它透明地在等待执行的一组进程之间切换可用的cpu。当进程没有执行时，xv6保存它的CPU寄存器，在下次运行该进程时恢复它们。内核将一个进程标识符(pid)与每个进程关联起来。

一个进程可以使用fork系统调用创建一个新的进程。fork()创建一个名为子进程的新进程，它的内存内容与被称为父进程的调用进程完全相同。fork()会在父进程和子进程中同时返回。在父进程中，fork返回子进程的pid;在子节点中，它返回0。例如，考虑下面用C语言[5]编写的程序片段:

```
int pid = fork();
if(pid > 0){
printf("parent: child=%d\en", pid);
pid = wait(0);
printf("child %d is done\en", pid);
} else if(pid == 0){
  printf("child: exiting\en");
exit(0);
} else {
printf("fork error\en");
}
```
exit() 系统调用导致调用进程停止执行，释放资源(内存, 已打开文件等)。Exit接受一个整数状态参数，通常0表示成功，1表示失败。wait系统调用返回当前进程已退出的子进程的pid，并将子进程的退出状态复制到传递给wait的地址;如果来电者的孩子都没有离开，wait会等待一个孩子离开。如果父进程不关心子进程的退出状态，它可以传递一个0地址来等待