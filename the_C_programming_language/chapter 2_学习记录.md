2.9

C语言提供了6个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符号或无符号char、short、int、long类型：
`&` 按位与（AND）
`|` 按位或（OR）
`^` 按位异或（XOR）
`<<` 左移
`>>` 右移
`~` 按位求反（一元运算符）
按位与运算符`&`经常用于屏蔽某些二进制位，例如：`n = n & 0177`该语句将n中除7个低二进制位外的其它各位均置为0;
补充：`0177 前面的0表示177是8进制数`

`x = x & ~077` 将把x的最后6位设置为0。注意，表达式`x & ~077`与机器字长无关，它比形式为`x & 0177700`的表达式要好，同为后者假定x是16位的数值。这种可移植的形式并没有增加额外开销，因为，`~077`是常量表达式，可以在编译时求值。

为了进一步说明某些位运算符，我们来看函数`getbits(x, p, n)`，它返回x中从右边数第p位开始向右数n位的字段。这里假定最右边的一位是第0位，n与p都是合理的正值。例如，`getbits(x, 4, 3)`返回x中第4、3、2三位的值。   
```cpp
/* getbits:  get n bits from position p */
unsigned getbits(unsigned x, int p, int n)
{
    return (x >> (p + 1 - n)) & ~(~0 << n);
}
```
其中，表达式`m << (p+1-n)`将期望获得的字段移位到字的最右端。`~0`的所有位都为1，这里使用语句`~0 << n`将~0左移n位，并将最右边的n位用0填补。再使用~运算对它按位取反，这样就建立了最右边n位全为1的屏蔽码。